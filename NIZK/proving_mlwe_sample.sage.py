# This file was *autogenerated* from the file proving_mlwe_sample.sage
from sage.all_cmdline import *   # import sage library

try:
    _sage_const_128
except NameError:
    # 当预处理器未生成 _sage_const_* 常量时，使用普通 Python 常量作为回退
    _sage_const_2 = 2
    _sage_const_4 = 4
    _sage_const_1 = 1
    _sage_const_12 = 12
    _sage_const_128 = 128
    _sage_const_59 = 59
    _sage_const_32 = 32
    _sage_const_8 = 8
    _sage_const_0 = 0
    _sage_const_1024 = 1024
    _sage_const_2048 = 2048
    _sage_const_16 = 16
    _sage_const_19 = 19
    _sage_const_337 = 337
    _sage_const_9 = 9
    _sage_const_1p0045 = 1.0045
    _sage_const_256 = 256
    _sage_const_5 = 5
    _sage_const_1p64 = 1.64
    _sage_const_26 = 26
    _sage_const_41 = 41
    _sage_const_3 = 3
    _sage_const_14 = 14
    _sage_const_6 = 6
    _sage_const_2p57 = 2.57
    _sage_const_2p25 = 2.25
    _sage_const_13 = 13
# This is the script for computing the non-interactive proof size
# of proving knowledge of a MLWE sample described in Section 6.2.
# Concretely, we want to prove knowledge of a vector s such that
# norm of ||(s,As-u)|| is at most B.

# -----------------------------
# 以下为中文注释版：帮助理解每段代码的作用（不改变原有逻辑）
# -----------------------------

# Function for estimating the MSIS hardness given parameters:
# add timestamp functionality
from datetime import datetime
import time
# a (n x m) matrix in \Rq along with the solution bound B. It returns the
# root Hermite factor \delta. We use the methodology presented by
# [GamNgu08, Mic08] and hence m is irrelevant.
def findMSISdelta(B, n, d, logq):
    # 中文：估计 MSIS 问题对应的 root Hermite factor（用于衡量格攻击难度）
    logC = log(B, _sage_const_2 )		
    logdelta = logC**_sage_const_2  / (_sage_const_4 *n*d*logq)
    return _sage_const_2 **logdelta

# Function for estimating the MLWE hardness for a (m x n) matrix in \Rq and 
# secret coefficients sampled uniformly at random between -nu and nu.
# We use the LWE-Estimator by [AlbPlaSco15] as a black-box.
def findMLWEdelta(nu, n, d, logq):
    # 中文：调用外部 LWE-estimator 脚本来估计 MLWE 的 root Hermite factor
    # 注意：这里把模块维度 n 扩展为 n * d（环/模扩展）
    load("https://bitbucket.org/malb/lwe-estimator/raw/HEAD/estimator.py")
    n = n * d
    q = _sage_const_2 **logq
    # compute stddev for uniform secret in [-nu,nu]
    stddev = sqrt(((_sage_const_2 *nu+_sage_const_1 )**_sage_const_2  - _sage_const_1 )/_sage_const_12 )
    alpha = alphaf(sigmaf(stddev),q)
    set_verbose(_sage_const_1 )
    # 使用 estimator 以不同内核模型（enum/sieve）估计安全性，取其中最保守的 delta
    L = estimate_lwe(n, alpha, q, reduction_cost_model=BKZ.enum)
    delta_enum1 = L['usvp']['delta_0'] 
    delta_enum2 = L['dec']['delta_0']  
    delta_enum3 = L['dual']['delta_0']  
    L = estimate_lwe(n, alpha, q, reduction_cost_model=BKZ.sieve)
    delta_sieve1 = L['usvp']['delta_0'] 
    delta_sieve2 = L['dec']['delta_0']  
    delta_sieve3 = L['dual']['delta_0']
    return max(delta_enum1,delta_enum2,delta_enum3,delta_sieve1,delta_sieve2,delta_sieve3)


# -----------------------------
# 参数定义区：设置安全参数、环维度、证明重复次数等
# -----------------------------
# Security parameter, ring dimension of \R and challenge space
secpam = _sage_const_128                             # security parameter (比特)
d = _sage_const_128                                  # ring dimension R = Z[X]/(X^d + 1)
l = _sage_const_2                                    # 参数 l（多项式因子数假设）
kappa = _sage_const_2                                # 挑战值最大系数范围，用于保证声音性
eta = _sage_const_59                                 # 启发式边界常数（经验值）

# Defining the log of the proof system modulus -- finding true values will come later 
nbofdiv = _sage_const_1                              # q 的质因子个数（通常 1 或 2）
logq1 = _sage_const_32                               # 最小素数因子 q1 的对数（近似）
logq = _sage_const_32                                # 证明系统模数 q 的对数（近似）
# lmbda 为增强声音性所需的重复次数（假设为偶数）
lmbda = _sage_const_2  * ceil( secpam/(_sage_const_2 *logq1) )    

# Length and size of the committed messages
m1 = _sage_const_8                                   # s1 的长度
m2 = _sage_const_0                                   # s2 的长度（后面会确定）
ell = _sage_const_0                                  # m 的长度
alpha = sqrt(_sage_const_1024 )                      # s1 的范数上界（示例值）

# Parameters for proving norm bounds
ve = _sage_const_1                                   # 精确范数证明个数
BoundsToProve = [sqrt(_sage_const_2048 )]            # 要证明的范数界 beta_i 列表
k_bin = _sage_const_0                                # 二进制证明向量长度（如果要证明二进制系数）
alphae = sqrt(_sage_const_2048  + ve*d)              # 组合向量 (s, As-u, ...) 的范数上界
ce = _sage_const_16  + ve                            # e^(e) 向量的长度
approximate_norm_proof = _sage_const_0               # 是否使用近似范数证明（布尔）
alphad = _sage_const_1                               # e^(d) 的范数上界（若不近似则为 1）

# Parameters for rejection sampling（拒绝采样相关参数）
gamma1 = _sage_const_19                              # s1 的拒绝采样参数
gamma2 = _sage_const_2                               # s2 的拒绝采样参数
gammae = _sage_const_2                               # Rs^(e) 的拒绝采样参数
gammad = _sage_const_1                               # R's^(d) 的拒绝采样参数（若不近似可忽略）

# Setting the standard deviations, apart from stdev2
stdev1 = gamma1 * eta * sqrt(alpha**_sage_const_2  + ve *d)
stdev2 = _sage_const_0 
stdeve = gammae * sqrt(_sage_const_337 ) * alphae
stdevd = gammad * sqrt(_sage_const_337 ) * alphad 

# -----------------------------
# 计算 MLWE 维度，使得 MLWE 难度约为 128-bit（通过 findMLWEdelta）
# -----------------------------
print("Computing the Module-LWE dimension...")
nu = _sage_const_1                                   # s2 的系数范围为 [-nu, nu]
mlwe =  _sage_const_9                                # 初始 MLWE 维度
mlwe_hardness = _sage_const_2 
# 循环增加 mlwe，直到 findMLWEdelta 返回值接近 1.0045（表示满足 128-bit 安全）
while mlwe_hardness > _sage_const_1p0045 :           
    mlwe += _sage_const_1                           
    mlwe_hardness = findMLWEdelta(nu,mlwe,d, logq)
    
    
# -----------------------------
# 计算 Module-SIS 维度 n，使 MSIS 难度满足安全目标
# -----------------------------
print("Computing the Module-SIS dimension...")
n = _sage_const_0                                                                                      # 初始化 n
D = _sage_const_0                                                                                      # D 用于丢弃低位
gamma = _sage_const_0                                                                                  # 用于丢弃低位的 gamma（后续确定）
value_n_found = false                                                                     # 标志是否找到合适的 n
# 不断增加 n，计算对应的 m2、stdev2、Bound，并检查 MSIS-hardness 条件
while value_n_found == false:
    n += _sage_const_1                                                                                 
    # m2 取 packing 优化后的长度估计
    m2 = mlwe + n + ell + lmbda/_sage_const_2  + _sage_const_256 /d + _sage_const_1  + approximate_norm_proof * _sage_const_256 /d + _sage_const_1            
    stdev2 = gamma2 * eta * nu * sqrt(m2 * d)                                             # 随 m2 更新 stdev2
    Bound1 =  _sage_const_2  * stdev1 * sqrt(_sage_const_2  * (m1 + ve) * d)                                        # bar{z}_1 的界
    Bound2 =  _sage_const_2  * stdev2 * sqrt(_sage_const_2  * m2 * d) + _sage_const_2 **D * eta * sqrt(n*d) + gamma * sqrt(n*d)   # bar{z}_2 的界
    Bound = _sage_const_4  * eta * sqrt(Bound1**_sage_const_2  + Bound2**_sage_const_2 )                                           # 提取的 MSIS 解的界
    # 检查 MSIS 的 delta 是否小于阈值（1.0045）且 Bound 小于 modulus q 的上界
    if findMSISdelta(Bound,n,d,logq) < _sage_const_1p0045  and Bound < _sage_const_2 **logq:
        value_n_found = true                                                              # 找到满足条件的 n




# -----------------------------
# 给定 n，搜索最大的 gamma，使 MSIS 解仍然足够小
# -----------------------------
print("Computing the parameter gamma...")
gamma = _sage_const_2 **logq                                                                            # 初始将 gamma 设为 2^logq
value_gamma_found = false                                                                 # 标志
while value_gamma_found == false:
    gamma /= _sage_const_2                                                                             # 逐步减小 gamma
    Bound1 =  _sage_const_2  * stdev1 * sqrt(_sage_const_2  * (m1 + ve) * d)                                        # 更新 Bound1
    Bound2 =  _sage_const_2  * stdev2 * sqrt(_sage_const_2  * m2 * d) + _sage_const_2 **D * eta * sqrt(n*d) + gamma * sqrt(n*d)   # 更新 Bound2
    Bound = _sage_const_4  * eta * sqrt(Bound1**_sage_const_2  + Bound2**_sage_const_2 )                                           # 更新 Bound
    if findMSISdelta(Bound,n,d,logq) < _sage_const_1p0045  and Bound < _sage_const_2 **logq:
        value_gamma_found = true                                                          # 找到合适的 gamma


# -----------------------------
# 计算模数 q1, q 等，使 q 的结构满足所需同余关系与质数条件
# -----------------------------
print("Computing moduli q1, q etc. ...")
true_gamma_found = false                                                                  # 标志
q1 = _sage_const_2 **(logq1) + (_sage_const_2 *l + _sage_const_1 )                                                                # q1 的初始候选（满足特定同余）
while true_gamma_found == false:
    q1 =  q1 - _sage_const_4 *l                                                                        # 迭代寻找满足条件的 q1
    while is_prime(q1) == False :                                                         # 确保 q1 为素数
        q1 -= _sage_const_4 *l
    if nbofdiv == _sage_const_1 :                                                                      # 若 q 只有一个质因子，则 q = q1
        q = q1
    else:
        # 若有两个质因子，需寻找 q2，使 q2 也为素数并满足同余关系
        q2 = _sage_const_4 *l * int(_sage_const_2 **(logq)/(_sage_const_4 *l*q1)) + _sage_const_2 *l  + _sage_const_1                                       
        while is_prime(q2) == False :                                                     # q2 必须为素数
            q2 -= _sage_const_4 *l
        q = q1 * q2                                                                       # q = q1 * q2
    Div_q = divisors(q-_sage_const_1 )                                                                 # 考虑 q-1 的约数
    for i in Div_q:                 
        # 选择一个约数 i，使其接近 gamma 且为偶数，用作最终 gamma
        if gamma*_sage_const_4 /_sage_const_5  < i and i <= gamma and is_even(i):                                   
            gamma = i                                                                     # 更新 gamma
            true_gamma_found = true


# -----------------------------
# 给定 n 和 gamma，找到最大的 D（丢弃 t_A 的低阶位）使得 MSIS 解仍然安全
# -----------------------------
print("Computing the parameter D...")
D = logq                                                                                        # 初始化 D
value_D_found = false                                                                           # 标志
while value_D_found == false:
    D -= _sage_const_1                                                                                       # 逐步减小 D
    Bound1 =  _sage_const_2  * stdev1 * sqrt(_sage_const_2  * (m1 + ve) * d)                                              # 重新计算 Bound1
    Bound2 =  _sage_const_2  * stdev2 * sqrt(_sage_const_2  * m2 * d) + _sage_const_2 **D * eta * sqrt(n*d) + gamma * sqrt(n*d)         # 重新计算 Bound2
    Bound = _sage_const_4  *  eta * sqrt(Bound1**_sage_const_2  + Bound2**_sage_const_2 )                                                 # 更新 Bound
    # 检查是否满足安全条件以及与 gamma、kappa 等关系
    if findMSISdelta(Bound,n,d,logq) < _sage_const_1p0045  and Bound < _sage_const_2 **logq and _sage_const_2 **(D-_sage_const_1 )*kappa*d < gamma:      
        value_D_found = true                                                                    # 找到合适的 D



# -----------------------------
# 检查知识声音性（Theorem 5.3 中的条件）
# -----------------------------
print("Checking knowledge soundness conditions...")
t = _sage_const_1p64                  
Be = _sage_const_2  * sqrt(_sage_const_256 /_sage_const_26 ) * t * stdeve 

if q <  _sage_const_41  * ce * d * Be:
    print("ERROR: can't use Lemma 2.9")

if q <= Be**_sage_const_2  + Be*sqrt(k_bin*d):
    print("ERROR: can't prove E_bin*s + v_bin has binary coefficients")

if q <= Be**_sage_const_2  + Be*sqrt(ve*d):
    print("ERROR: can't prove all x_i have binary coefficients")

for bound in BoundsToProve:
    if q <= _sage_const_3  * bound**_sage_const_2  + Be**_sage_const_2 :
        print("ERROR: can't prove || E_i*s - v_i || <= beta_i")


# -----------------------------
# 输出最终计算得到的参数（便于查看）
# -----------------------------
print("---------- computed parameters ----------")
print("The smallest prime divisor q1 of q: ", q1)
print("Proof system modulus q: ", q)
print("Parameter gamma for dropping low-order bits of w: ", gamma)
print("Parameter D for dropping low-order bits of t_A : ", D)
print("Module-SIS dimension: ", n)
print("Module-LWE dimension: ", mlwe)
print("Length of the randomness vector s2: ", m2)
print("Log2 of the standard deviation stdev1: ",round(log(stdev1,_sage_const_2 ),_sage_const_2 ))
print("Log2 of the standard deviation stdev2: ",round(log(stdev2,_sage_const_2 ),_sage_const_2 ))
print("Log2 of the standard deviation stdeve: ",round(log(stdeve,_sage_const_2 ),_sage_const_2 ))
print("Timestamp after parameter computation: ", datetime.now())


# -----------------------------
# 输出安全性分析（重复率、声音性误差、MLWE/MSIS 难度等）
# -----------------------------
print("---------- security analysis ------------")

# Repetition rate
rep_rate = _sage_const_2 *exp(_sage_const_14 /gamma1 + _sage_const_1 /(_sage_const_2 *gamma1**_sage_const_2 )) * exp(_sage_const_1 /(_sage_const_2 *gamma2**_sage_const_2 )) * exp(_sage_const_1 /(_sage_const_2 *gammae**_sage_const_2 )) * ((_sage_const_1 -approximate_norm_proof) + approximate_norm_proof*exp(_sage_const_1 /(_sage_const_2 *gammad**_sage_const_2 )))
print("Repetition rate: ", round(rep_rate ,_sage_const_2  ))

# Knowledge soundness error from Theorem 5.3
soundness_error = _sage_const_2  * _sage_const_1 /(_sage_const_2 *kappa+_sage_const_1 )**(d/_sage_const_2 ) +  q1**(-d/l) + q1**(-lmbda) + _sage_const_2 **(-_sage_const_128 ) + approximate_norm_proof*_sage_const_2 **(-_sage_const_256 )
print("Log of the knowledge soundness error: ", ceil(log(soundness_error, _sage_const_2 )) )

# Exact Module-SIS and Module-LWE hardness
Bound1 =  _sage_const_2  * stdev1 * sqrt(_sage_const_2  * (m1 + ve) * d)
Bound2 =  _sage_const_2  * stdev2 * sqrt(_sage_const_2  * m2 * d) + _sage_const_2 **D * eta * sqrt(n*d) + gamma * sqrt(n*d)
Bound = _sage_const_4  *  eta * sqrt(Bound1**_sage_const_2  + Bound2**_sage_const_2 )
print("Root Hermite factor for MSIS: ", round( findMSISdelta(Bound,n,d,logq) ,_sage_const_6 )) 
print("Root Hermite factor for MLWE: ", round(mlwe_hardness,_sage_const_6 )) 

# 输出 Bound1, Bound2 和 Bound 以便确认数值（调试/记录）
print("Bound1 =", Bound1)
print("Bound2 =", Bound2)
print("Bound  =", Bound)

# -----------------------------
# 估计证明大小（以 KB 输出），包含 full-sized 多项式、challenge、short-sized 等部分
# -----------------------------
print("---------- proof size -------------------")
start_proof = time.perf_counter()

# 修复：把 full_size 与 challenge 等表达式写成独立、语法正确的行（原处出现行拼接导致语法错误）
full_size = n * d * (logq - D) + (ell + _sage_const_256 / d + _sage_const_1 + approximate_norm_proof * _sage_const_256 / d + lmbda + _sage_const_1) * d * logq
challenge = ceil(log(_sage_const_2 * kappa + _sage_const_1, _sage_const_2)) * d
short_size1 = (m1 + ve) * d * (ceil(log(stdev1, _sage_const_2) + _sage_const_2p57)) + (m2 - n) * d * (ceil(log(stdev2, _sage_const_2) + _sage_const_2p57))
short_size2 = _sage_const_256 * (ceil(log(stdeve, _sage_const_2) + _sage_const_2p57)) + approximate_norm_proof * _sage_const_256 * (ceil(log(stdevd, _sage_const_2) + _sage_const_2p57))
hint = _sage_const_2p25 * n * d

print("Total proof size in KB: ", round((full_size + challenge + short_size1 + short_size2 + hint)/(_sage_const_2 **_sage_const_13 ) , _sage_const_2 ))
print("full-sized polynomials in KB: ", round(full_size/(_sage_const_2 **_sage_const_13 ) , _sage_const_2 ))
print("challenge c in KB: ", round(challenge/(_sage_const_2 **_sage_const_13 ) , _sage_const_2 ))
print("short-sized polynomials in KB: ", round((short_size1 + short_size2 + hint)/(_sage_const_2 **_sage_const_13 ) , _sage_const_2 ))
print("Timestamp after proof computation: ", datetime.now())

elapsed_proof = time.perf_counter() - start_proof
print("Proof-size computation time: {:.6f} s".format(elapsed_proof))

